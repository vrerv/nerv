<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ğŸ® ì¸í˜•ë½‘ê¸° Physics</title>
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-DCRN1EHVS8"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-DCRN1EHVS8');
    </script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; -webkit-tap-highlight-color: transparent; }
        html, body { width: 100%; height: 100%; overflow: hidden; position: fixed; background: #1a1a2e; font-family: system-ui, sans-serif; }
        #canvas { display: block; width: 100%; height: 100%; }
        
        .ui-top { position: fixed; top: 10px; left: 10px; display: flex; gap: 8px; z-index: 100; padding-top: env(safe-area-inset-top); }
        .stat-box { background: rgba(0,0,0,0.8); padding: 6px 10px; border-radius: 15px; border: 2px solid #ffd700; color: #fff; font-weight: bold; font-size: 0.85rem; white-space: nowrap; }
        .stat-box span { color: #00ffff; }
        
        /* ìƒíƒœ í‘œì‹œ */
        .status-display { position: fixed; top: 70px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); padding: 10px 20px; border-radius: 15px; border: 2px solid #00ff00; color: #00ff00; font-size: 1rem; font-weight: bold; z-index: 150; opacity: 0; transition: opacity 0.2s; text-align: center; }
        .status-display.visible { opacity: 1; }
        .status-display.warning { border-color: #ffaa00; color: #ffaa00; }
        .status-display.danger { border-color: #ff4444; color: #ff4444; }
        
        /* ê·¸ë¦½ë ¥ ê²Œì´ì§€ */
        .grip-display { position: fixed; top: 120px; left: 50%; transform: translateX(-50%); width: 200px; z-index: 150; opacity: 0; transition: opacity 0.3s; }
        .grip-display.visible { opacity: 1; }
        .grip-label { color: #fff; font-size: 0.8rem; text-align: center; margin-bottom: 5px; }
        .grip-bar { height: 12px; background: #222; border-radius: 6px; overflow: hidden; border: 1px solid #444; }
        .grip-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #ff4444, #ffaa00, #00ff00); transition: width 0.1s; border-radius: 6px; }
        
        .ui-bottom { position: fixed; bottom: 15px; left: 0; right: 0; padding: 0 15px; padding-bottom: env(safe-area-inset-bottom); z-index: 100; }
        
        /* ì›í˜• íŒŒì›Œ ê²Œì´ì§€ - ë²„íŠ¼ì„ ê°ì‹¸ëŠ” í˜•íƒœ */
        .grab-wrapper { position: relative; width: 140px; height: 140px; }
        .power-ring { position: absolute; top: 0; left: 0; width: 140px; height: 140px; transform: rotate(-90deg); }
        .power-ring-bg { fill: none; stroke: #333; stroke-width: 8; }
        .power-ring-fill { fill: none; stroke-width: 8; stroke-linecap: round; stroke-dasharray: 408; stroke-dashoffset: 408; transition: stroke-dashoffset 0.05s linear; }
        .power-ring-sweet { fill: none; stroke: rgba(0,255,0,0.3); stroke-width: 12; stroke-dasharray: 40.8 367.2; stroke-dashoffset: -163.2; }
        .power-ring-marker { fill: none; stroke: #fff; stroke-width: 2; stroke-dasharray: 4 404; stroke-dashoffset: 0; }
        
        .controls-row { display: flex; justify-content: space-between; align-items: center; }
        
        .dpad { display: grid; grid-template-columns: repeat(3, 50px); grid-template-rows: repeat(3, 50px); gap: 4px; }
        .dpad-btn { background: linear-gradient(180deg, rgba(80,80,80,0.9) 0%, rgba(40,40,40,0.95) 100%); border: 2px solid rgba(255,255,255,0.15); border-radius: 10px; color: #fff; font-size: 1.4rem; display: flex; align-items: center; justify-content: center; }
        .dpad-btn:active, .dpad-btn.active { background: linear-gradient(180deg, #00aaff 0%, #0066aa 100%); border-color: #00ffff; transform: scale(0.95); }
        .dpad-btn.empty { background: transparent; border: none; }
        
        .grab-btn { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100px; height: 100px; background: linear-gradient(180deg, #00dd66 0%, #00aa44 100%); border: 4px solid #00ff88; border-radius: 50%; color: #fff; font-size: 1rem; font-weight: bold; display: flex; flex-direction: column; align-items: center; justify-content: center; box-shadow: 0 7px 0 #007733, 0 10px 20px rgba(0,0,0,0.4); }
        .grab-btn:active, .grab-btn.active { transform: translate(-50%, calc(-50% + 5px)); box-shadow: 0 2px 0 #007733; background: linear-gradient(180deg, #00ff77 0%, #00cc55 100%); }
        .grab-btn:disabled { background: linear-gradient(180deg, #555 0%, #333 100%); border-color: #666; box-shadow: 0 7px 0 #222; }
        .grab-btn .icon { font-size: 2rem; margin-bottom: 2px; }
        
        .collection { position: fixed; top: 70px; right: 15px; background: rgba(0,0,0,0.8); padding: 8px 12px; border-radius: 12px; border: 2px solid #ffd700; z-index: 100; }
        .collection-title { color: #ffd700; font-size: 0.7rem; margin-bottom: 4px; }
        .collection-items { font-size: 1.1rem; display: flex; flex-wrap: wrap; gap: 2px; }
        
        .feedback { position: fixed; top: 35%; left: 50%; transform: translate(-50%, -50%); font-size: 3.5rem; font-weight: bold; pointer-events: none; z-index: 1000; animation: popFeedback 1s ease-out forwards; }
        .feedback.perfect { color: #00ff00; text-shadow: 0 0 40px #00ff00; }
        .feedback.good { color: #ffaa00; text-shadow: 0 0 30px #ffaa00; }
        .feedback.fail { color: #ff4444; text-shadow: 0 0 20px #ff4444; }
        
        @keyframes popFeedback { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; } 20% { transform: translate(-50%, -50%) scale(1.4); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1) translateY(-50px); opacity: 0; } }
        
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        
        @media (max-height: 600px) { .dpad { grid-template-columns: repeat(3, 42px); grid-template-rows: repeat(3, 42px); } .grab-wrapper { width: 120px; height: 120px; } .power-ring { width: 120px; height: 120px; } .grab-btn { width: 85px; height: 85px; } }
        
        /* ë„ì›€ë§ ë²„íŠ¼ */
        .help-btn { position: fixed; top: 10px; right: 15px; width: 36px; height: 36px; background: rgba(0,0,0,0.8); border: 2px solid #ffd700; border-radius: 50%; color: #ffd700; font-size: 1.2rem; font-weight: bold; display: flex; align-items: center; justify-content: center; z-index: 100; cursor: pointer; padding-top: env(safe-area-inset-top); }
        .help-btn:active { background: rgba(255,215,0,0.3); }
        
        /* ë„ì›€ë§ ëª¨ë‹¬ */
        .help-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 200; display: none; align-items: center; justify-content: center; padding: 20px; }
        .help-modal.visible { display: flex; }
        .help-content { background: #1a1a2e; border: 3px solid #ffd700; border-radius: 20px; padding: 20px; max-width: 360px; max-height: 80vh; overflow-y: scroll; color: #fff; font-size: 0.9rem; line-height: 1.5; touch-action: pan-y; -webkit-overflow-scrolling: touch; }
        .help-content * { touch-action: pan-y; }
        .help-content h2 { color: #ffd700; font-size: 1.3rem; margin-bottom: 15px; text-align: center; }
        .help-content h3 { color: #00ffff; font-size: 1rem; margin: 15px 0 8px; border-bottom: 1px solid #333; padding-bottom: 4px; }
        .help-content ul { list-style: none; padding-left: 0; }
        .help-content li { margin: 6px 0; padding-left: 20px; position: relative; }
        .help-content li::before { content: "â€¢"; position: absolute; left: 5px; color: #ffd700; }
        .help-content .tip { background: rgba(0,255,0,0.1); border-left: 3px solid #00ff00; padding: 8px 12px; margin: 10px 0; border-radius: 0 8px 8px 0; }
        .help-content table { width: 100%; border-collapse: collapse; margin: 8px 0; font-size: 0.85rem; }
        .help-content th, .help-content td { padding: 6px 8px; text-align: left; border-bottom: 1px solid #333; }
        .help-content th { color: #ffd700; }
        .help-close { display: block; width: 100%; margin-top: 15px; padding: 12px; background: linear-gradient(180deg, #ffd700 0%, #cc9900 100%); border: none; border-radius: 10px; color: #000; font-size: 1rem; font-weight: bold; cursor: pointer; }
        .help-close:active { background: linear-gradient(180deg, #ffee55 0%, #ddaa00 100%); }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="ui-top">
        <div class="stat-box">ğŸ“Š Lv.<span id="level">1</span></div>
        <div class="stat-box">ğŸª™ <span id="coins">10</span></div>
        <div class="stat-box">ğŸ† <span id="wins">0</span>/<span id="target">6</span></div>
    </div>
    
    <div class="status-display" id="status">ëŒ€ê¸° ì¤‘...</div>
    
    <div class="grip-display" id="gripDisplay">
        <div class="grip-label">ğŸ’ª ê·¸ë¦½ë ¥: <span id="gripPercent">0</span>%</div>
        <div class="grip-bar"><div class="grip-fill" id="gripFill"></div></div>
    </div>
    
    <div class="collection">
        <div class="collection-title">ğŸ€ Collection</div>
        <div class="collection-items" id="collection"></div>
    </div>
    
    <button class="help-btn" id="helpBtn">?</button>
    
    <div class="help-modal" id="helpModal">
        <div class="help-content">
            <h2>ğŸ® ì¸í˜•ë½‘ê¸° ë„ì›€ë§</h2>
            
            <h3>ğŸ•¹ï¸ ì¡°ì‘ë²•</h3>
            <ul>
                <li><strong>ë°©í–¥í‚¤</strong>: í¬ë ˆì¸ ì´ë™</li>
                <li><strong>GRAB ë²„íŠ¼</strong>: ê¾¹ ëˆŒëŸ¬ì„œ íŒŒì›Œ ê²Œì´ì§€ ì¶©ì „ â†’ ë–¼ë©´ ë½‘ê¸°!</li>
                <li><strong>ë“œë˜ê·¸</strong>: í™”ë©´ ì•µê¸€ ì¡°ì ˆ</li>
                <li><strong>í•€ì¹˜/ìŠ¤í¬ë¡¤</strong>: í™”ë©´ í™•ëŒ€/ì¶•ì†Œ</li>
            </ul>
            
            <h3>ğŸ¯ íŒŒì›Œ ê²Œì´ì§€ íƒ€ì´ë°</h3>
            <p>ì›í˜• ê²Œì´ì§€ê°€ ì°¨ì˜¤ë¥¼ ë•Œ <strong style="color:#00ff00;">ì´ˆë¡ìƒ‰ êµ¬ê°„(45-55%)</strong>ì—ì„œ ë–¼ë©´ ìµœê³  ê·¸ë¦½ë ¥!</p>
            <table>
                <tr><th>êµ¬ê°„</th><th>ê·¸ë¦½ë ¥</th></tr>
                <tr><td>45-55%</td><td>95% â­</td></tr>
                <tr><td>35-65%</td><td>75%</td></tr>
                <tr><td>25-75%</td><td>50%</td></tr>
                <tr><td>ê·¸ ì™¸</td><td>25%</td></tr>
            </table>
            
            <h3>ğŸ§¸ ì¸í˜• ì¢…ë¥˜</h3>
            <table>
                <tr><th>ì¸í˜•</th><th>ë‚œì´ë„</th><th>íŠ¹ì§•</th></tr>
                <tr><td>ğŸ§¸âœ¨ ë”í”¼</td><td>ì‰¬ì›€</td><td>ë¯¸í‚¤ ë¬´ëŠ¬, ê°€ë²¼ì›€</td></tr>
                <tr><td>ğŸ§¸ ê³°</td><td>ë³´í†µ</td><td>ê¸°ë³¸</td></tr>
                <tr><td>ğŸ° í† ë¼</td><td>ì–´ë ¤ì›€</td><td>ê¸´ ê·€, ë¯¸ë„ëŸ¬ì›€</td></tr>
                <tr><td>ğŸ± ê³ ì–‘ì´</td><td>ë§¤ìš° ì–´ë ¤ì›€</td><td>ë°œë²„ë‘¥, ë¬´ê±°ì›€</td></tr>
            </table>
            
            <h3>ğŸ“Š ë ˆë²¨ ì‹œìŠ¤í…œ</h3>
            <ul>
                <li>ëª¨ë“  ì¸í˜•ì„ ì¡ìœ¼ë©´ <strong>ë ˆë²¨ í´ë¦¬ì–´!</strong></li>
                <li>ë ˆë²¨ì´ ì˜¬ë¼ê°ˆìˆ˜ë¡ ì¸í˜• ìˆ˜ ì¦ê°€</li>
                <li>ë ˆë²¨ì´ ì˜¬ë¼ê°ˆìˆ˜ë¡ ì–´ë ¤ìš´ ì¸í˜• ë¹„ìœ¨ ì¦ê°€</li>
                <li>ì§„í–‰ ìƒí™©ì€ ìë™ ì €ì¥ë©ë‹ˆë‹¤</li>
            </ul>
            
            <h3>ğŸ’¡ íŒ</h3>
            <div class="tip">
                <ul>
                    <li>ì¸í˜• <strong>ì •ì¤‘ì•™</strong>ì„ ë…¸ë ¤ë¼!</li>
                    <li><strong>ë”í”¼</strong>ë¶€í„° ì¡ìœ¼ë©´ ì„±ê³µë¥  UP</li>
                    <li>ê³ ì–‘ì´ëŠ” ë°œë²„ë‘¥ ì³ì„œ ë¯¸ë„ëŸ¬ì§€ê¸° ì‰¬ì›€</li>
                </ul>
            </div>
            
            <button class="help-close" id="helpClose">ë‹«ê¸°</button>
            <button class="help-close" id="lunarNewYear" style="margin-top: 8px;">ğŸ§§ ì¦ê±°ìš´ ì„¤ë‚ !</button>
        </div>
    </div>
    
    <div class="ui-bottom">
        <div class="controls-row">
            <div class="dpad" id="dpad">
                <div class="dpad-btn empty"></div>
                <button class="dpad-btn" data-dir="up">â†‘</button>
                <div class="dpad-btn empty"></div>
                <button class="dpad-btn" data-dir="left">â†</button>
                <div class="dpad-btn empty"></div>
                <button class="dpad-btn" data-dir="right">â†’</button>
                <div class="dpad-btn empty"></div>
                <button class="dpad-btn" data-dir="down">â†“</button>
                <div class="dpad-btn empty"></div>
            </div>
            <div class="grab-wrapper">
                <svg class="power-ring" viewBox="0 0 140 140">
                    <!-- ë°°ê²½ ì› -->
                    <circle class="power-ring-bg" cx="70" cy="70" r="65"/>
                    <!-- ìµœì  êµ¬ê°„ í‘œì‹œ (ìœ„ìª½ = 45-55%) -->
                    <circle class="power-ring-sweet" cx="70" cy="70" r="65"/>
                    <!-- 12ì‹œ ë°©í–¥ ë§ˆì»¤ -->
                    <circle class="power-ring-marker" cx="70" cy="70" r="65"/>
                    <!-- íŒŒì›Œ ê²Œì´ì§€ -->
                    <circle class="power-ring-fill" id="powerFill" cx="70" cy="70" r="65"/>
                </svg>
                <button class="grab-btn" id="grabBtn"><span class="icon">ğŸ¦€</span>GRAB</button>
            </div>
        </div>
    </div>

    <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ìƒíƒœ
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const state = {
            craneX: 0, craneZ: 0,
            coins: 24, wins: 0,
            level: 1,
            isDropping: false, isCharging: false,
            power: 0, powerDir: 1,
            moveX: 0, moveZ: 0,
            prizes: [], collection: [],
            currentGrip: 0,
            grabbedPrize: null,
            phase: 'idle' // idle, descending, grabbing, ascending, releasing
        };

        const BOUNDS = { x: 2.2, z: 1.8 };
        const GRAVITY = 0.015;
        const BOUNCE = 0.4;
        const FRICTION = 0.95;
        
        // ë ˆë²¨ë³„ ì„¤ì •
        function getLevelConfig(level) {
            const baseCount = 6;
            const prizeCount = Math.min(baseCount + Math.floor((level - 1) * 1.5), 20); // ìµœëŒ€ 20ê°œ
            const coinsPerPrize = Math.max(3 - Math.floor(level / 5) * 0.5, 1.5); // ë ˆë²¨ ì˜¬ë¼ê°ˆìˆ˜ë¡ ì½”ì¸ ì¤„ì–´ë“¦
            
            // ë ˆë²¨ ì˜¬ë¼ê°ˆìˆ˜ë¡ ì–´ë ¤ìš´ ì¸í˜• ë¹„ìœ¨ ì¦ê°€
            const duffyRate = Math.max(0.15 - level * 0.01, 0.02);  // 15% â†’ 2%
            const catRate = Math.min(0.1 + level * 0.03, 0.4);      // 10% â†’ 40%
            const rabbitRate = Math.min(0.1 + level * 0.02, 0.3);   // 10% â†’ 30%
            // ë‚˜ë¨¸ì§€ëŠ” ê³°
            
            return {
                prizeCount,
                coins: Math.ceil(prizeCount * coinsPerPrize),
                target: prizeCount, // ëª¨ë‘ ì¡ì•„ì•¼ í´ë¦¬ì–´
                rates: { duffy: duffyRate, cat: catRate, rabbit: rabbitRate }
            };
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ğŸ”Š ì‚¬ìš´ë“œ ì‹œìŠ¤í…œ (Web Audio API)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        let audioCtx = null;
        
        function initAudio() {
            if (!audioCtx) audioCtx = new AudioCtx();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }
        
        function playTone(freq, duration, type = 'square', volume = 0.3, decay = true) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.value = freq;
            gain.gain.value = volume;
            if (decay) gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }
        
        function playNoise(duration, volume = 0.2) {
            if (!audioCtx) return;
            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const gain = audioCtx.createGain();
            gain.gain.value = volume;
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 800;
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            noise.start();
        }
        
        const SFX = {
            move: () => playTone(150, 0.05, 'square', 0.1),
            descend: () => { playTone(200, 0.3, 'sawtooth', 0.15); playNoise(0.3, 0.1); },
            ascend: () => { playTone(300, 0.3, 'sawtooth', 0.15); playNoise(0.3, 0.1); },
            grab: () => { playTone(400, 0.1, 'square', 0.2); playTone(500, 0.1, 'square', 0.2); },
            success: () => {
                [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => playTone(f, 0.2, 'square', 0.25), i * 100));
            },
            slip: () => { playTone(300, 0.15, 'sawtooth', 0.3); playTone(150, 0.3, 'sawtooth', 0.25); },
            fail: () => { playTone(200, 0.2, 'square', 0.2); playTone(150, 0.3, 'square', 0.2); },
            coin: () => { playTone(1200, 0.1, 'square', 0.2); playTone(1600, 0.15, 'square', 0.2); },
            button: () => playTone(800, 0.05, 'square', 0.15),
            bounce: () => playTone(100 + Math.random() * 100, 0.1, 'sine', 0.15),
            // ğŸ± ê³ ì–‘ì´ ì•¼ì˜¹!
            meow: () => {
                playTone(600, 0.1, 'sine', 0.25);
                setTimeout(() => playTone(800, 0.15, 'sine', 0.2), 100);
                setTimeout(() => playTone(500, 0.2, 'sine', 0.15), 200);
            },
            // ğŸ‰ ë ˆë²¨ì—…!
            levelUp: () => {
                [523, 659, 784, 880, 1047, 1319].forEach((f, i) => 
                    setTimeout(() => playTone(f, 0.25, 'square', 0.3), i * 80)
                );
            },
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Three.js
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const canvas = document.getElementById('canvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        // í™”ë©´ ê°€ë¡œ í¬ê¸°ì— ë”°ë¼ ì¹´ë©”ë¼ ê±°ë¦¬ ì¡°ì ˆ (ì¢ì„ìˆ˜ë¡ ë” ë©€ë¦¬)
        function getCameraDistance() {
            const width = window.innerWidth;
            if (width >= 768) return { y: 5, z: 6 };
            // 320px ~ 768px ë²”ìœ„ì—ì„œ ì„ í˜• ë³´ê°„
            const t = Math.max(0, Math.min(1, (768 - width) / (768 - 320)));
            return { y: 5 + t * 2, z: 6 + t * 3 }; // y: 5~7, z: 6~9
        }
        const camDist = getCameraDistance();
        camera.position.set(0, camDist.y, camDist.z);

        const controls = new OrbitControls(camera, canvas);
        controls.target.set(0, 1, 0);
        controls.enableDamping = true;
        controls.maxPolarAngle = Math.PI / 2.1;
        controls.minDistance = 3;
        controls.maxDistance = 12;
        controls.enablePan = false;
        controls.update();

        // ì¡°ëª…
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(3, 8, 4);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(1024, 1024);
        scene.add(dirLight);
        
        const pinkLight = new THREE.PointLight(0xff66aa, 0.5, 10);
        pinkLight.position.set(-3, 4, 0);
        scene.add(pinkLight);

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ê¸°ê³„
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const machine = new THREE.Group();
        
        // ë°”ë‹¥
        const floor = new THREE.Mesh(
            new THREE.BoxGeometry(5.5, 0.2, 4.5),
            new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.8 })
        );
        floor.receiveShadow = true;
        machine.add(floor);
        
        // ê·¸ë¦¬ë“œ (ê¸°ë³¸ off, ë ˆë²¨ë§ì—ì„œ ì‚¬ìš©)
        const grid = new THREE.GridHelper(5, 10, 0x6633aa, 0x4422aa);
        grid.position.y = 0.11;
        grid.visible = false; // ê¸°ë³¸ off
        machine.add(grid);
        
        // ê·¸ë¦¬ë“œ on/off í•¨ìˆ˜ (ë ˆë²¨ë§ì—ì„œ ì‚¬ìš©)
        window.setGridVisible = function(visible) {
            grid.visible = visible;
        };
        
        // ë²½ (ì¶©ëŒìš©)
        const wallMat = new THREE.MeshStandardMaterial({ color: 0x3a2a5a, transparent: true, opacity: 0.3 });
        const walls = [
            { pos: [0, 1, -2.1], size: [5.5, 2, 0.1] },
            { pos: [0, 1, 2.1], size: [5.5, 2, 0.1] },
            { pos: [-2.6, 1, 0], size: [0.1, 2, 4.5] },
            { pos: [2.6, 1, 0], size: [0.1, 2, 4.5] }
        ];
        walls.forEach(w => {
            const wall = new THREE.Mesh(new THREE.BoxGeometry(...w.size), wallMat);
            wall.position.set(...w.pos);
            machine.add(wall);
        });
        
        // í”„ë ˆì„
        const frameMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.7, roughness: 0.3 });
        const pillarGeo = new THREE.CylinderGeometry(0.08, 0.08, 4, 12);
        [[-2.5, 2, -2], [2.5, 2, -2], [-2.5, 2, 2], [2.5, 2, 2]].forEach(pos => {
            const pillar = new THREE.Mesh(pillarGeo, frameMat);
            pillar.position.set(...pos);
            pillar.castShadow = true;
            machine.add(pillar);
        });
        
        scene.add(machine);

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ì¸í˜• (ë¬¼ë¦¬ í¬í•¨)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function createPlushie(color, type = 'bear') {
            const plushie = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.9 });
            
            // ê³ ì–‘ì´ëŠ” 20% ë” í¬ê³  ê¸¸ì­‰! ë”í”¼ëŠ” 15% ë” í¼!
            const scale = type === 'cat' ? 1.2 : type === 'duffy' ? 1.15 : type === 'rabbit' ? 1.15 : 1.0;
            const bodyStretch = type === 'cat' ? 1.5 : 1.0; // ê³ ì–‘ì´ ëª¸í†µ ê¸¸ì­‰
            
            if (type === 'duffy') {
                // ğŸ§¸ ë”í”¼! ë””ì¦ˆë‹ˆ ë² ì–´!
                const duffyBrown = new THREE.MeshStandardMaterial({ color: 0xd4a574, roughness: 0.95 }); // ì—°í•œ ê°ˆìƒ‰
                const duffyLight = new THREE.MeshStandardMaterial({ color: 0xf5e6d3, roughness: 0.95 }); // ë°ì€ ë² ì´ì§€
                const duffySailor = new THREE.MeshStandardMaterial({ color: 0x2255aa, roughness: 0.8 }); // ì„¸ì¼ëŸ¬ë³µ íŒŒë‘
                const duffyWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9 });
                const duffyRed = new THREE.MeshStandardMaterial({ color: 0xcc2222, roughness: 0.8 });
                
                // ëª¸í†µ (í†µí†µ)
                const body = new THREE.Mesh(new THREE.SphereGeometry(0.26 * scale, 16, 16), duffyBrown);
                body.position.y = 0.26 * scale;
                body.castShadow = true;
                plushie.add(body);
                
                // ì„¸ì¼ëŸ¬ë³µ ìƒì˜
                const sailorTop = new THREE.Mesh(new THREE.CylinderGeometry(0.22 * scale, 0.26 * scale, 0.18 * scale, 16), duffySailor);
                sailorTop.position.y = 0.32 * scale;
                plushie.add(sailorTop);
                
                // ì„¸ì¼ëŸ¬ ì¹¼ë¼ (í°ìƒ‰)
                const collarGeo = new THREE.TorusGeometry(0.2 * scale, 0.03 * scale, 8, 16, Math.PI);
                const collar = new THREE.Mesh(collarGeo, duffyWhite);
                collar.rotation.x = Math.PI / 2;
                collar.rotation.z = Math.PI;
                collar.position.set(0, 0.42 * scale, 0.08 * scale);
                plushie.add(collar);
                
                // ë¹¨ê°„ ë¦¬ë³¸
                const ribbonGeo = new THREE.BoxGeometry(0.08 * scale, 0.04 * scale, 0.02 * scale);
                const ribbon = new THREE.Mesh(ribbonGeo, duffyRed);
                ribbon.position.set(0, 0.42 * scale, 0.18 * scale);
                plushie.add(ribbon);
                
                // ë¨¸ë¦¬ (í†µí†µ, ì•½ê°„ í¼)
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.22 * scale, 16, 16), duffyBrown);
                head.position.y = 0.62 * scale;
                head.castShadow = true;
                plushie.add(head);
                
                // ğŸ­ ì–¼êµ´ì˜ ë¯¸í‚¤ ë§ˆìš°ìŠ¤ ë¬´ëŠ¬! (ë°ì€ ë² ì´ì§€)
                // ì¤‘ì•™ ì›
                const mickeyCenter = new THREE.Mesh(new THREE.CircleGeometry(0.1 * scale, 16), duffyLight);
                mickeyCenter.position.set(0, 0.6 * scale, 0.2 * scale);
                plushie.add(mickeyCenter);
                // ì™¼ìª½ ê·€
                const mickeyEarL = new THREE.Mesh(new THREE.CircleGeometry(0.05 * scale, 12), duffyLight);
                mickeyEarL.position.set(-0.08 * scale, 0.68 * scale, 0.19 * scale);
                plushie.add(mickeyEarL);
                // ì˜¤ë¥¸ìª½ ê·€
                const mickeyEarR = new THREE.Mesh(new THREE.CircleGeometry(0.05 * scale, 12), duffyLight);
                mickeyEarR.position.set(0.08 * scale, 0.68 * scale, 0.19 * scale);
                plushie.add(mickeyEarR);
                
                // ë™ê·¸ë€ ê·€ (í…Œë””ë² ì–´ ê·€)
                const earGeo = new THREE.SphereGeometry(0.08 * scale, 12, 12);
                [-0.16, 0.16].forEach(x => {
                    const ear = new THREE.Mesh(earGeo, duffyBrown);
                    ear.position.set(x * scale, 0.78 * scale, 0);
                    ear.scale.z = 0.6;
                    ear.castShadow = true;
                    plushie.add(ear);
                    // ê·€ ì•ˆìª½ (ë°ì€ìƒ‰)
                    const innerEar = new THREE.Mesh(new THREE.SphereGeometry(0.05 * scale, 10, 10), duffyLight);
                    innerEar.position.set(x * scale, 0.78 * scale, 0.02 * scale);
                    innerEar.scale.z = 0.5;
                    plushie.add(innerEar);
                });
                
                // ëˆˆ (ë°˜ì§ì´ëŠ” ê²€ì€ ëˆˆ)
                const eyeMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.3 });
                [-0.06, 0.06].forEach(x => {
                    const eye = new THREE.Mesh(new THREE.SphereGeometry(0.025 * scale, 10, 10), eyeMat);
                    eye.position.set(x * scale, 0.62 * scale, 0.19 * scale);
                    plushie.add(eye);
                    // í•˜ì´ë¼ì´íŠ¸
                    const highlight = new THREE.Mesh(new THREE.SphereGeometry(0.008 * scale, 6, 6), duffyWhite);
                    highlight.position.set(x * scale + 0.01 * scale, 0.63 * scale, 0.21 * scale);
                    plushie.add(highlight);
                });
                
                // ì½” (ê°ˆìƒ‰ íƒ€ì›)
                const noseMat = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.7 });
                const nose = new THREE.Mesh(new THREE.SphereGeometry(0.03 * scale, 8, 8), noseMat);
                nose.scale.set(1.2, 0.8, 0.8);
                nose.position.set(0, 0.55 * scale, 0.2 * scale);
                plushie.add(nose);
                
                // íŒ”ë‹¤ë¦¬ (í†µí†µí•œ ê°ˆìƒ‰)
                const limbGeo = new THREE.CapsuleGeometry(0.06 * scale, 0.12 * scale, 6, 8);
                // íŒ”
                [[-0.22, 0.28, 0.08], [0.22, 0.28, 0.08]].forEach((pos, i) => {
                    const arm = new THREE.Mesh(limbGeo, duffyBrown);
                    arm.position.set(pos[0] * scale, pos[1] * scale, pos[2] * scale);
                    arm.rotation.z = i === 0 ? 0.5 : -0.5;
                    arm.castShadow = true;
                    plushie.add(arm);
                });
                // ë‹¤ë¦¬
                [[-0.1, 0.08, 0.05], [0.1, 0.08, 0.05]].forEach(pos => {
                    const leg = new THREE.Mesh(limbGeo, duffyBrown);
                    leg.position.set(pos[0] * scale, pos[1] * scale, pos[2] * scale);
                    leg.rotation.x = 0.3;
                    leg.castShadow = true;
                    plushie.add(leg);
                });
                
                // ğŸ­ ì—‰ë©ì´ ë¯¸í‚¤ ë²„ìŠ¤ë§ˆí¬!
                const birthmark = new THREE.Mesh(new THREE.CircleGeometry(0.03 * scale, 12), duffyLight);
                birthmark.position.set(0.08 * scale, 0.2 * scale, -0.24 * scale);
                birthmark.rotation.y = Math.PI;
                plushie.add(birthmark);
                const bmEarL = new THREE.Mesh(new THREE.CircleGeometry(0.015 * scale, 8), duffyLight);
                bmEarL.position.set(0.06 * scale, 0.24 * scale, -0.24 * scale);
                bmEarL.rotation.y = Math.PI;
                plushie.add(bmEarL);
                const bmEarR = new THREE.Mesh(new THREE.CircleGeometry(0.015 * scale, 8), duffyLight);
                bmEarR.position.set(0.1 * scale, 0.24 * scale, -0.24 * scale);
                bmEarR.rotation.y = Math.PI;
                plushie.add(bmEarR);
                
            } else if (type === 'cat') {
                // ğŸ± ê³ ì–‘ì´ - ê¸¸ì­‰í•œ ëª¸í†µ!
                const bodyGeo = new THREE.CapsuleGeometry(0.18 * scale, 0.25 * scale * bodyStretch, 8, 12);
                const body = new THREE.Mesh(bodyGeo, mat);
                body.rotation.x = Math.PI / 2; // ê°€ë¡œë¡œ ëˆ•íˆê¸°
                body.position.y = 0.2 * scale;
                body.castShadow = true;
                plushie.add(body);
                
                // ë¨¸ë¦¬ (ì•½ê°„ ë‚©ì‘)
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.16 * scale, 12, 12), mat);
                head.scale.z = 0.85; // ì‚´ì§ ë‚©ì‘
                head.position.set(0, 0.4 * scale, 0.22 * scale);
                head.castShadow = true;
                plushie.add(head);
                
                // ì‚¼ê°í˜• ê·€! (ë¾°ì¡±)
                const earGeo = new THREE.ConeGeometry(0.06 * scale, 0.12 * scale, 4);
                [-0.09, 0.09].forEach((x, i) => {
                    const ear = new THREE.Mesh(earGeo, mat);
                    ear.position.set(x * scale, 0.55 * scale, 0.18 * scale);
                    ear.rotation.z = i === 0 ? 0.2 : -0.2;
                    ear.rotation.x = -0.2;
                    ear.castShadow = true;
                    plushie.add(ear);
                });
                // ê·€ ì•ˆìª½ (ë¶„í™)
                const innerEarMat = new THREE.MeshStandardMaterial({ color: 0xffaaaa, roughness: 0.9 });
                const innerEarGeo = new THREE.ConeGeometry(0.03 * scale, 0.08 * scale, 4);
                [-0.09, 0.09].forEach((x, i) => {
                    const innerEar = new THREE.Mesh(innerEarGeo, innerEarMat);
                    innerEar.position.set(x * scale, 0.54 * scale, 0.2 * scale);
                    innerEar.rotation.z = i === 0 ? 0.2 : -0.2;
                    innerEar.rotation.x = -0.2;
                    plushie.add(innerEar);
                });
                
                // ë…¸ë€ ëˆˆ + ì„¸ë¡œ ë™ê³µ!
                const eyeWhiteMat = new THREE.MeshStandardMaterial({ color: 0xffee44, roughness: 0.5 });
                const pupilMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
                [-0.055, 0.055].forEach(x => {
                    // ëˆˆ (ë…¸ë€ìƒ‰)
                    const eye = new THREE.Mesh(new THREE.SphereGeometry(0.04 * scale, 8, 8), eyeWhiteMat);
                    eye.position.set(x * scale, 0.43 * scale, 0.32 * scale);
                    plushie.add(eye);
                    // ì„¸ë¡œ ë™ê³µ
                    const pupilGeo = new THREE.CapsuleGeometry(0.008 * scale, 0.025 * scale, 4, 4);
                    const pupil = new THREE.Mesh(pupilGeo, pupilMat);
                    pupil.position.set(x * scale, 0.43 * scale, 0.36 * scale);
                    plushie.add(pupil);
                });
                
                // ë¶„í™ ì½” (ì—­ì‚¼ê°í˜•)
                const noseMat = new THREE.MeshStandardMaterial({ color: 0xff9999, roughness: 0.8 });
                const noseGeo = new THREE.ConeGeometry(0.025 * scale, 0.02 * scale, 3);
                const nose = new THREE.Mesh(noseGeo, noseMat);
                nose.rotation.x = Math.PI;
                nose.position.set(0, 0.36 * scale, 0.32 * scale);
                plushie.add(nose);
                
                // ìˆ˜ì—¼! (6ê°œ)
                const whiskerMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
                const whiskerGeo = new THREE.CylinderGeometry(0.003, 0.003, 0.12 * scale, 4);
                [-1, 1].forEach(side => {
                    [-0.08, 0, 0.08].forEach((yOff, i) => {
                        const whisker = new THREE.Mesh(whiskerGeo, whiskerMat);
                        whisker.rotation.z = Math.PI / 2;
                        whisker.rotation.y = side * 0.2;
                        whisker.position.set(side * 0.1 * scale, 0.35 * scale + yOff * 0.15, 0.3 * scale);
                        plushie.add(whisker);
                    });
                });
                
                // ë°œ 4ê°œ!
                const pawMat = new THREE.MeshStandardMaterial({ color: 0xffdddd, roughness: 0.9 });
                const pawGeo = new THREE.SphereGeometry(0.05 * scale, 8, 8);
                [[-0.1, 0.05, 0.12], [0.1, 0.05, 0.12], [-0.1, 0.05, -0.18], [0.1, 0.05, -0.18]].forEach(pos => {
                    const paw = new THREE.Mesh(pawGeo, pawMat);
                    paw.position.set(pos[0] * scale, pos[1] * scale, pos[2] * scale);
                    paw.scale.y = 0.6;
                    plushie.add(paw);
                });
                
                // ê¼¬ë¦¬! (ê¸¸ê³  êµ¬ë¶€ëŸ¬ì§)
                const tailGeo = new THREE.CapsuleGeometry(0.03 * scale, 0.2 * scale, 4, 8);
                const tail = new THREE.Mesh(tailGeo, mat);
                tail.position.set(0, 0.25 * scale, -0.32 * scale);
                tail.rotation.x = -0.8;
                tail.rotation.z = 0.3;
                tail.castShadow = true;
                plushie.add(tail);
                
                // ê¼¬ë¦¬ ë
                const tailTip = new THREE.Mesh(new THREE.SphereGeometry(0.04 * scale, 8, 8), mat);
                tailTip.position.set(0.08 * scale, 0.4 * scale, -0.38 * scale);
                plushie.add(tailTip);
                
            } else {
                // ëª¸í†µ
                const body = new THREE.Mesh(new THREE.SphereGeometry(0.22 * scale, 12, 12), mat);
                body.position.y = 0.22 * scale;
                body.castShadow = true;
                plushie.add(body);
                
                // ë¨¸ë¦¬
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.18 * scale, 12, 12), mat);
                head.position.y = 0.52 * scale;
                head.castShadow = true;
                plushie.add(head);
                
                // ê·€ (í† ë¼ëŠ” ê¸¸ì­‰í•˜ê²Œ)
                if (type === 'rabbit') {
                    // í† ë¼ ê·€ (ê¸¸ê³  ì«‘ê¸‹)
                    const earGeo = new THREE.CapsuleGeometry(0.04 * scale, 0.2 * scale, 4, 8);
                    [-0.08, 0.08].forEach((x, i) => {
                        const ear = new THREE.Mesh(earGeo, mat);
                        ear.position.set(x * scale, 0.85 * scale, 0);
                        ear.rotation.z = i === 0 ? 0.15 : -0.15;
                        ear.castShadow = true;
                        plushie.add(ear);
                    });
                    // ë¶„í™ìƒ‰ ê·€ ì•ˆìª½
                    const innerEarMat = new THREE.MeshStandardMaterial({ color: 0xffaaaa, roughness: 0.9 });
                    const innerEarGeo = new THREE.CapsuleGeometry(0.02 * scale, 0.12 * scale, 4, 8);
                    [-0.08, 0.08].forEach((x, i) => {
                        const innerEar = new THREE.Mesh(innerEarGeo, innerEarMat);
                        innerEar.position.set(x * scale, 0.85 * scale, 0.02);
                        innerEar.rotation.z = i === 0 ? 0.15 : -0.15;
                        plushie.add(innerEar);
                    });
                } else {
                    // ê³° ê·€ (ë™ê·¸ë—ê²Œ)
                    const earGeo = new THREE.SphereGeometry(0.06 * scale, 8, 8);
                    [-0.11, 0.11].forEach(x => {
                        const ear = new THREE.Mesh(earGeo, mat);
                        ear.position.set(x * scale, 0.68 * scale, 0);
                        ear.scale.y = 1.3;
                        plushie.add(ear);
                    });
                }
                
                // ëˆˆ
                const eyeMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
                const eyeSize = type === 'rabbit' ? 0.035 : 0.03;
                [-0.06, 0.06].forEach(x => {
                    const eye = new THREE.Mesh(new THREE.SphereGeometry(eyeSize * scale, 8, 8), eyeMat);
                    eye.position.set(x * scale, 0.55 * scale, 0.14 * scale);
                    plushie.add(eye);
                });
                
                // ì½” (í† ë¼ëŠ” ë¶„í™ìƒ‰)
                const noseMat = new THREE.MeshStandardMaterial({ color: type === 'rabbit' ? 0xff9999 : 0x333333 });
                const nose = new THREE.Mesh(new THREE.SphereGeometry(0.025 * scale, 8, 8), noseMat);
                nose.position.set(0, 0.48 * scale, 0.16 * scale);
                plushie.add(nose);
            }
            
            return plushie;
        }

        function spawnPrizes(overrideCount) {
            state.prizes.forEach(p => scene.remove(p.mesh));
            state.prizes = [];
            
            const config = getLevelConfig(state.level);
            if (overrideCount) config.prizeCount = overrideCount;
            
            const bearColors = [0xff9999, 0x99ff99, 0x9999ff, 0xffff99, 0xff99ff, 0x99ffff, 0xffcc99, 0xcc99ff];
            const rabbitColors = [0xffffff, 0xffddee, 0xeeddff, 0xffffee]; // í† ë¼ëŠ” ë°ì€ ìƒ‰
            // ğŸ± ê³ ì–‘ì´ ìƒ‰ìƒë“¤!
            const catColors = [
                0xff9944, // ì£¼í™©
                0x888888, // íšŒìƒ‰
                0xffeecc, // í¬ë¦¼
                0x333333, // ê²€ì •
                0xffffff, // í°ìƒ‰
            ];
            // ğŸ§¸ ë”í”¼ëŠ” ê³ ì • ìƒ‰ìƒ!
            const duffyColor = 0xd4a574;
            
            for (let i = 0; i < config.prizeCount; i++) {
                // ë ˆë²¨ë³„ í™•ë¥  ì ìš©
                const rand = Math.random();
                const { duffy, cat, rabbit } = config.rates;
                const type = rand < duffy ? 'duffy' : rand < duffy + cat ? 'cat' : rand < duffy + cat + rabbit ? 'rabbit' : 'bear';
                const colors = type === 'duffy' ? [duffyColor] : type === 'cat' ? catColors : type === 'rabbit' ? rabbitColors : bearColors;
                const color = colors[Math.floor(Math.random() * colors.length)];
                const mesh = createPlushie(color, type);
                
                // ë¬´ê²Œ ê¸°ë°˜ ìŠ¬ë¦½ í™•ë¥  (ë¬´ê±°ìš¸ìˆ˜ë¡ ìŠ¬ë¦½ í™•ë¥  ì¦ê°€)
                // ê³°=1.0(ê¸°ì¤€), í† ë¼=1.2, ê³ ì–‘ì´=1.4(ê°€ì¥ ë¬´ê±°ì›€), ë”í”¼=0.8(ê°€ë²¼ì›€)
                const weight = type === 'cat' ? 1.4 : type === 'rabbit' ? 1.2 : type === 'duffy' ? 0.8 : 1.0;
                // ë¶€í”¼ (í´ìˆ˜ë¡ ìœ„ì¹˜ ì •í™•ë„ê°€ ì¤‘ìš”)
                const volume = type === 'cat' ? 1.4 : type === 'duffy' ? 1.15 : type === 'rabbit' ? 1.15 : 1.0;
                // ê³ ì–‘ì´ëŠ” ê·¸ë¦½ë ¥ 20% ë” í•„ìš”, ë”í”¼ëŠ” ì¡ê¸° ì‰¬ì›€!
                const gripRequired = type === 'cat' ? 1.2 : type === 'duffy' ? 0.8 : 1.0;
                
                let x, z, overlap, tries = 0;
                const spacing = type === 'cat' ? 0.9 : type === 'duffy' ? 0.85 : type === 'rabbit' ? 0.8 : 0.6; // ê³ ì–‘ì´ > ë”í”¼ > í† ë¼
                do {
                    x = (Math.random() - 0.5) * 4;
                    z = (Math.random() - 0.5) * 3;
                    overlap = state.prizes.some(p => Math.abs(p.x - x) < spacing && Math.abs(p.z - z) < spacing);
                    tries++;
                } while (overlap && tries < 30);
                
                const yOffset = type === 'cat' ? 0.15 : type === 'duffy' ? 0.14 : type === 'rabbit' ? 0.12 : 0.1;
                mesh.position.set(x, yOffset, z);
                mesh.rotation.y = Math.random() * Math.PI * 2;
                scene.add(mesh);
                
                state.prizes.push({
                    mesh, x, z, y: yOffset,
                    vx: 0, vy: 0, vz: 0,
                    color, type, weight, volume, gripRequired,
                    grabbed: false,
                    isHeld: false,
                    bobOffset: Math.random() * Math.PI * 2,
                    strugglePhase: 0 // ê³ ì–‘ì´ ë°œë²„ë‘¥ ì• ë‹ˆë©”ì´ì…˜ìš©
                });
            }
            
            // ë ˆë²¨ ì„¤ì •ì— ë”°ë¥¸ ì½”ì¸
            state.coins = config.coins;
            document.getElementById('coins').textContent = state.coins;
            document.getElementById('level').textContent = state.level;
            document.getElementById('target').textContent = config.target;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // í¬ë ˆì¸ (ê´€ì ˆ ìˆëŠ” ì§‘ê²Œ)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const crane = new THREE.Group();
        const goldMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.7, roughness: 0.3 });
        const metalMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8, roughness: 0.3 });
        
        // íŠ¸ë¡¤ë¦¬
        const trolley = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.2, 0.5), goldMat);
        trolley.position.y = 3.8;
        trolley.castShadow = true;
        crane.add(trolley);
        
        // ë¡œí”„
        const rope = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 1.2, 8), metalMat);
        rope.position.y = 3.1;
        crane.add(rope);
        
        // ì§‘ê²Œ ê·¸ë£¹
        const clawGroup = new THREE.Group();
        clawGroup.position.y = 2.5;
        crane.add(clawGroup);
        
        // í—ˆë¸Œ
        const hub = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.12, 0.12, 8), goldMat);
        hub.castShadow = true;
        clawGroup.add(hub);
        
        // ì†ê°€ë½ (ê´€ì ˆ í¬í•¨)
        const fingers = [];
        for (let i = 0; i < 3; i++) {
            const finger = new THREE.Group();
            const angle = (i / 3) * Math.PI * 2;
            finger.position.set(Math.sin(angle) * 0.08, -0.06, Math.cos(angle) * 0.08);
            finger.userData.baseAngle = angle;
            finger.userData.openRotation = 0.4;
            finger.userData.closedRotation = 0.05;
            finger.rotation.x = finger.userData.openRotation;
            
            // ìƒë‹¨ ì„¸ê·¸ë¨¼íŠ¸
            const seg1 = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.25, 0.03), metalMat);
            seg1.position.y = -0.12;
            seg1.castShadow = true;
            finger.add(seg1);
            
            // í•˜ë‹¨ ì„¸ê·¸ë¨¼íŠ¸ (ê´€ì ˆ)
            const joint = new THREE.Group();
            joint.position.y = -0.25;
            finger.add(joint);
            finger.userData.joint = joint;
            
            const seg2 = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.15, 0.04), metalMat);
            seg2.position.y = -0.07;
            seg2.castShadow = true;
            joint.add(seg2);
            
            // íŒ
            const tip = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), metalMat);
            tip.position.y = -0.15;
            tip.castShadow = true;
            joint.add(tip);
            
            clawGroup.add(finger);
            fingers.push(finger);
        }
        
        scene.add(crane);
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ì§‘ê²Œ ì• ë‹ˆë©”ì´ì…˜
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function setClawState(openAmount) { // 0 = closed, 1 = open
            fingers.forEach(f => {
                const targetRot = f.userData.closedRotation + (f.userData.openRotation - f.userData.closedRotation) * openAmount;
                f.rotation.x = targetRot;
                // ê´€ì ˆë„ í•¨ê»˜ ì›€ì§ì„
                f.userData.joint.rotation.x = openAmount * 0.3;
            });
        }
        
        function animateClawClose(duration = 300) {
            return new Promise(resolve => {
                const start = performance.now();
                const startOpen = 1;
                
                function animate() {
                    const t = Math.min((performance.now() - start) / duration, 1);
                    setClawState(1 - t);
                    if (t < 1) requestAnimationFrame(animate);
                    else resolve();
                }
                animate();
            });
        }
        
        function animateClawOpen(duration = 200) {
            return new Promise(resolve => {
                const start = performance.now();
                
                function animate() {
                    const t = Math.min((performance.now() - start) / duration, 1);
                    setClawState(t);
                    if (t < 1) requestAnimationFrame(animate);
                    else resolve();
                }
                animate();
            });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ë¬¼ë¦¬ ì—…ë°ì´íŠ¸
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function updatePhysics() {
            state.prizes.forEach(p => {
                if (p.grabbed || p.isHeld) return;
                
                // ì¤‘ë ¥
                p.vy -= GRAVITY;
                
                // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                p.x += p.vx;
                p.y += p.vy;
                p.z += p.vz;
                
                // ë°”ë‹¥ ì¶©ëŒ
                if (p.y < 0.1) {
                    if (p.vy < -0.05) SFX.bounce(); // ì¶©ë¶„íˆ ë¹ ë¥´ë©´ ì†Œë¦¬
                    p.y = 0.1;
                    p.vy *= -BOUNCE;
                    p.vx *= FRICTION;
                    p.vz *= FRICTION;
                }
                
                // ë²½ ì¶©ëŒ
                if (p.x < -2.3) { p.x = -2.3; p.vx *= -BOUNCE; }
                if (p.x > 2.3) { p.x = 2.3; p.vx *= -BOUNCE; }
                if (p.z < -1.9) { p.z = -1.9; p.vz *= -BOUNCE; }
                if (p.z > 1.9) { p.z = 1.9; p.vz *= -BOUNCE; }
                
                // ë§ˆì°°
                p.vx *= FRICTION;
                p.vz *= FRICTION;
                
                // ë©”ì‹œ ì—…ë°ì´íŠ¸
                p.mesh.position.set(p.x, p.y, p.z);
            });
            
            // ì¸í˜• ê°„ ì¶©ëŒ ì²˜ë¦¬
            const activePrizes = state.prizes.filter(p => !p.grabbed && !p.isHeld);
            for (let i = 0; i < activePrizes.length; i++) {
                for (let j = i + 1; j < activePrizes.length; j++) {
                    const p1 = activePrizes[i];
                    const p2 = activePrizes[j];
                    
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const dz = p2.z - p1.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    
                    // ì¸í˜• í¬ê¸°ì— ë”°ë¥¸ ì¶©ëŒ ë°˜ê²½ (íƒ€ì…ë³„ í¬ê¸° ê³ ë ¤)
                    const r1 = p1.type === 'cat' ? 0.35 : p1.type === 'duffy' ? 0.32 : 0.28;
                    const r2 = p2.type === 'cat' ? 0.35 : p2.type === 'duffy' ? 0.32 : 0.28;
                    const minDist = r1 + r2;
                    
                    if (dist < minDist && dist > 0.001) {
                        // ê²¹ì¹¨ í•´ì†Œ - ì„œë¡œ ë°€ì–´ë‚´ê¸°
                        const overlap = minDist - dist;
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const nz = dz / dist;
                        
                        // ìœ„ì¹˜ ë¶„ë¦¬ (ê°ê° ì ˆë°˜ì”©)
                        const sep = overlap * 0.5;
                        p1.x -= nx * sep;
                        p1.y -= ny * sep;
                        p1.z -= nz * sep;
                        p2.x += nx * sep;
                        p2.y += ny * sep;
                        p2.z += nz * sep;
                        
                        // ì†ë„ êµí™˜ (íƒ„ì„± ì¶©ëŒ)
                        const relVx = p1.vx - p2.vx;
                        const relVy = p1.vy - p2.vy;
                        const relVz = p1.vz - p2.vz;
                        const relVn = relVx * nx + relVy * ny + relVz * nz;
                        
                        if (relVn > 0) { // ì„œë¡œ ì ‘ê·¼ ì¤‘ì¼ ë•Œë§Œ
                            const impulse = relVn * BOUNCE;
                            p1.vx -= impulse * nx;
                            p1.vy -= impulse * ny;
                            p1.vz -= impulse * nz;
                            p2.vx += impulse * nx;
                            p2.vy += impulse * ny;
                            p2.vz += impulse * nz;
                        }
                        
                        // ë©”ì‹œ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                        p1.mesh.position.set(p1.x, p1.y, p1.z);
                        p2.mesh.position.set(p2.x, p2.y, p2.z);
                    }
                }
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ë“œë¡­ ë¡œì§
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const statusEl = document.getElementById('status');
        const gripDisplay = document.getElementById('gripDisplay');
        const gripFill = document.getElementById('gripFill');
        const gripPercent = document.getElementById('gripPercent');
        
        function setStatus(text, type = '') {
            statusEl.textContent = text;
            statusEl.className = 'status-display visible ' + type;
        }
        
        function hideStatus() {
            statusEl.classList.remove('visible');
            gripDisplay.classList.remove('visible');
        }
        
        function setGrip(percent) {
            state.currentGrip = percent;
            gripPercent.textContent = Math.round(percent);
            gripFill.style.width = percent + '%';
            gripDisplay.classList.add('visible');
        }

        async function drop() {
            if (state.isDropping || state.coins <= 0) return;
            
            state.isDropping = true;
            state.coins--;
            document.getElementById('coins').textContent = state.coins;
            document.getElementById('grabBtn').disabled = true;
            
            const power = state.power;
            state.power = 0;
            
            // íŒŒì›Œì— ë”°ë¥¸ ê·¸ë¦½ë ¥ ê³„ì‚°
            let gripStrength;
            if (power >= 45 && power <= 55) gripStrength = 95;
            else if (power >= 35 && power <= 65) gripStrength = 75;
            else if (power >= 25 && power <= 75) gripStrength = 50;
            else gripStrength = 25;
            
            // Phase 1: ë‚´ë ¤ê°€ê¸°
            state.phase = 'descending';
            setStatus('â¬‡ï¸ ë‚´ë ¤ê°€ëŠ” ì¤‘...', '');
            SFX.descend();
            
            const targetY = 0.8;
            await animateCrane(targetY);
            
            // Phase 2: ì¡ê¸°
            state.phase = 'grabbing';
            setStatus('ğŸ¦€ ì¡ëŠ” ì¤‘...', '');
            SFX.grab();
            
            await animateClawClose(400);
            
            // ì¡ì„ ìˆ˜ ìˆëŠ” ì¸í˜• ì²´í¬
            let grabbed = null;
            let bestDist = Infinity;
            
            for (const p of state.prizes) {
                if (p.grabbed) continue;
                const dx = p.x - state.craneX;
                const dz = p.z - state.craneZ;
                const dist = Math.sqrt(dx * dx + dz * dz);
                if (dist < 0.5 && dist < bestDist) {
                    grabbed = p;
                    bestDist = dist;
                }
            }
            
            if (grabbed) {
                // ê±°ë¦¬ì— ë”°ë¥¸ ê·¸ë¦½ë ¥ ë³´ì • (ê³ ì–‘ì´ëŠ” gripRequiredë¡œ ë‚˜ëˆ”!)
                const distFactor = 1 - (bestDist / 0.5);
                const gripReq = grabbed.gripRequired || 1.0;
                const finalGrip = (gripStrength * distFactor) / gripReq;
                setGrip(finalGrip);
                
                grabbed.isHeld = true;
                state.grabbedPrize = grabbed;
                
                const typeEmoji = grabbed.type === 'duffy' ? 'ğŸ§¸âœ¨' : grabbed.type === 'cat' ? 'ğŸ±' : grabbed.type === 'rabbit' ? 'ğŸ°' : 'ğŸ§¸';
                const typeWarning = grabbed.type === 'duffy' ? ' (ë”í”¼! ì¡ê¸° ì‰¬ì›€!)' : grabbed.type === 'cat' ? ' (ë¬´ê²ê³  ë¯¸ë„ëŸ¬ì›€!)' : grabbed.type === 'rabbit' ? ' (ë¯¸ë„ëŸ¬ì›€!)' : '';
                
                // ğŸ± ê³ ì–‘ì´ ì¡ìœ¼ë©´ ì•¼ì˜¹!
                if (grabbed.type === 'cat') SFX.meow();
                
                if (finalGrip >= 70) {
                    setStatus(`âœŠ ${typeEmoji} ì¡ì•˜ë‹¤! (${Math.round(finalGrip)}%)${typeWarning}`, grabbed.type === 'rabbit' ? 'warning' : '');
                } else if (finalGrip >= 40) {
                    setStatus(`ğŸ˜° ${typeEmoji} ë¶ˆì•ˆì •... (${Math.round(finalGrip)}%)${typeWarning}`, 'warning');
                } else {
                    setStatus(`ğŸ˜± ${typeEmoji} ìœ„í—˜! (${Math.round(finalGrip)}%)${typeWarning}`, 'danger');
                }
                
                await sleep(500);
                
                // Phase 3: ì˜¬ë¼ê°€ê¸°
                state.phase = 'ascending';
                setStatus('â¬†ï¸ ì˜¬ë¼ê°€ëŠ” ì¤‘...', finalGrip >= 50 ? '' : 'warning');
                SFX.ascend();
                
                // ìŠ¬ë¦½ í™•ë¥  ê³„ì‚° (íƒ€ì…ë³„ ìŠ¬ë¦½ í™•ë¥  ì œê±°, ë¬´ê²Œ + ìœ„ì¹˜/ë¶€í”¼ ê¸°ë°˜)
                // 1. ìœ„ì¹˜ ë¶€ì •í™•ì„±: ê±°ë¦¬ê°€ ë©€ìˆ˜ë¡ ë†’ìŒ (0~1)
                const positionInaccuracy = 1 - distFactor;
                // 2. ë¶€í”¼ ì˜í–¥: ë¶€í”¼ê°€ í´ìˆ˜ë¡ ìœ„ì¹˜ ë¶€ì •í™•ì„±ì´ ìŠ¬ë¦½ì— ë” ì˜í–¥
                const volumeEffect = 1 + positionInaccuracy * (grabbed.volume - 1);
                // 3. ê¸°ë³¸ ìŠ¬ë¦½ í™•ë¥  (ê·¸ë¦½ë ¥ ê¸°ë°˜)
                const baseSlipChance = finalGrip < 40 ? 0.8 : finalGrip < 60 ? 0.4 : finalGrip < 80 ? 0.1 : 0.02;
                // 4. ìµœì¢… ìŠ¬ë¦½ í™•ë¥  = ê¸°ë³¸ * ë¬´ê²Œ * ë¶€í”¼íš¨ê³¼
                const slipChance = baseSlipChance * grabbed.weight * volumeEffect;
                let slipped = false;
                
                const startY = clawGroup.position.y;
                const endY = 2.5;
                const duration = 600;
                const startTime = performance.now();
                
                await new Promise(resolve => {
                    function animate() {
                        const elapsed = performance.now() - startTime;
                        const t = Math.min(elapsed / duration, 1);
                        const ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                        
                        const newY = startY + (endY - startY) * ease;
                        clawGroup.position.y = newY;
                        
                        const ropeLen = 3.7 - newY;
                        rope.scale.y = ropeLen / 1.2;
                        rope.position.y = 3.7 - ropeLen / 2;
                        
                        if (grabbed && grabbed.isHeld) {
                            // ê³ ì–‘ì´ëŠ” ë” ë§ì´ í”ë“¤ë¦¼!
                            const swingAmp = grabbed.type === 'cat' ? 0.06 : 0.02;
                            const swingSpeed = grabbed.type === 'cat' ? 0.02 : 0.01;
                            
                            grabbed.mesh.position.y = newY - 0.35;
                            grabbed.mesh.position.x = state.craneX + Math.sin(elapsed * swingSpeed) * swingAmp;
                            grabbed.mesh.position.z = state.craneZ + Math.cos(elapsed * swingSpeed * 1.2) * swingAmp;
                            grabbed.y = grabbed.mesh.position.y;
                            grabbed.x = grabbed.mesh.position.x;
                            grabbed.z = grabbed.mesh.position.z;
                            
                            // ğŸ± ê³ ì–‘ì´ ë°œë²„ë‘¥ ëª¨ì…˜!
                            if (grabbed.type === 'cat') {
                                grabbed.strugglePhase += 0.15;
                                grabbed.mesh.rotation.y = Math.sin(grabbed.strugglePhase) * 0.5;
                                grabbed.mesh.rotation.z = Math.cos(grabbed.strugglePhase * 1.3) * 0.2;
                                grabbed.mesh.rotation.x = Math.sin(grabbed.strugglePhase * 0.8) * 0.15;
                            }
                            
                            // ëœë¤ ë¯¸ë„ëŸ¬ì§ ì²´í¬
                            if (!slipped && Math.random() < slipChance * 0.02) {
                                slipped = true;
                                grabbed.isHeld = false;
                                grabbed.vy = 0;
                                grabbed.vx = (Math.random() - 0.5) * 0.1;
                                grabbed.vz = (Math.random() - 0.5) * 0.1;
                                state.grabbedPrize = null;
                                const slipMsg = grabbed.type === 'cat' ? 'ğŸ± ë°œë²„ë‘¥!' : 'ğŸ˜± ë¯¸ë„ëŸ¬ì¡Œë‹¤!';
                                setStatus(slipMsg, 'danger');
                                showFeedback(grabbed.type === 'cat' ? 'ğŸ± ESCAPE!' : 'SLIP!', 'fail');
                                SFX.slip();
                            }
                        }
                        
                        if (t < 1) requestAnimationFrame(animate);
                        else resolve();
                    }
                    animate();
                });
                
                // ìµœì¢… ê²°ê³¼
                if (grabbed.isHeld && !slipped) {
                    // ì„±ê³µ!
                    state.wins++;
                    const prizeEmoji = grabbed.type === 'duffy' ? 'ğŸ§¸âœ¨' : grabbed.type === 'cat' ? 'ğŸ±' : grabbed.type === 'rabbit' ? 'ğŸ°' : 'ğŸ§¸';
                    state.collection.push(prizeEmoji);
                    document.getElementById('wins').textContent = state.wins;
                    document.getElementById('collection').innerHTML = state.collection.join(' ');
                    
                    const isDuffy = grabbed.type === 'duffy';
                    const isCat = grabbed.type === 'cat';
                    const isRabbit = grabbed.type === 'rabbit';
                    
                    if (isDuffy) {
                        showFeedback('ğŸ§¸ DUFFY!', 'perfect');
                        setStatus('ğŸ‰ ë”í”¼ íšë“! ë””ì¦ˆë‹ˆ ë² ì–´!', '');
                    } else if (isCat) {
                        showFeedback('ğŸ± CAT!', 'perfect');
                        setStatus('ğŸ‰ ê³ ì–‘ì´ ì¡ì•˜ë‹¤! (ë¬´ê±°ì›€!)', '');
                    } else if (isRabbit) {
                        showFeedback('ğŸ° RARE!', 'perfect');
                        setStatus('ğŸ‰ ë ˆì–´ í† ë¼ íšë“!', '');
                    } else {
                        showFeedback(finalGrip >= 80 ? 'PERFECT!' : 'GOOD!', finalGrip >= 80 ? 'perfect' : 'good');
                        setStatus('ğŸ‰ ì„±ê³µ!', '');
                    }
                    SFX.success();
                    
                    grabbed.grabbed = true;
                    grabbed.isHeld = false;
                    scene.remove(grabbed.mesh);
                    
                    // ë ˆë²¨ í´ë¦¬ì–´ ì²´í¬
                    const config = getLevelConfig(state.level);
                    if (state.wins >= config.target) {
                        await sleep(500);
                        await levelUp();
                        return; // levelUpì—ì„œ ê²Œì„ ìƒíƒœ ë¦¬ì…‹
                    }
                }
            } else {
                setStatus('âŒ ë¹—ë‚˜ê°!', 'danger');
                SFX.fail();
                await sleep(300);
                
                // ë¹—ë‚˜ê°”ì–´ë„ ì˜¬ë¼ê°€ì•¼ í•¨!
                state.phase = 'ascending';
                setStatus('â¬†ï¸ ì˜¬ë¼ê°€ëŠ” ì¤‘...', '');
                SFX.ascend();
                await animateCrane(2.5);
            }
            
            // Phase 4: ì—´ê¸°
            state.phase = 'releasing';
            await animateClawOpen(200);
            
            if (state.grabbedPrize && state.grabbedPrize.isHeld) {
                state.grabbedPrize.isHeld = false;
                state.grabbedPrize.vy = 0;
            }
            state.grabbedPrize = null;
            
            await sleep(200);
            hideStatus();
            
            state.isDropping = false;
            state.phase = 'idle';
            document.getElementById('grabBtn').disabled = state.coins <= 0;
            
            if (state.coins <= 0) {
                await sleep(500);
                const config = getLevelConfig(state.level);
                const remaining = config.target - state.wins;
                const duffyCount = state.collection.filter(e => e === 'ğŸ§¸âœ¨').length;
                const catCount = state.collection.filter(e => e === 'ğŸ±').length;
                const rabbitCount = state.collection.filter(e => e === 'ğŸ°').length;
                
                let msg = `ğŸ“Š ë ˆë²¨ ${state.level} ì‹¤íŒ¨!\n`;
                msg += `ğŸ† ${state.wins}/${config.target}ê°œ (${remaining}ê°œ ë‚¨ìŒ)\n\n`;
                if (state.collection.length > 0) {
                    msg += `íšë“í•œ ì¸í˜•:\n`;
                    if (duffyCount > 0) msg += `ğŸ§¸âœ¨ ë”í”¼ ${duffyCount}ë§ˆë¦¬\n`;
                    if (catCount > 0) msg += `ğŸ± ê³ ì–‘ì´ ${catCount}ë§ˆë¦¬\n`;
                    if (rabbitCount > 0) msg += `ğŸ° í† ë¼ ${rabbitCount}ë§ˆë¦¬\n`;
                    const bearCount = state.collection.filter(e => e === 'ğŸ§¸').length;
                    if (bearCount > 0) msg += `ğŸ§¸ ê³° ${bearCount}ë§ˆë¦¬\n`;
                }
                msg += `\nì´ ë ˆë²¨ ë‹¤ì‹œ ë„ì „í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`;
                
                const retry = confirm(msg);
                if (retry) {
                    resetGame(true); // ë ˆë²¨ ìœ ì§€
                } else {
                    if (state.level > 1 && confirm('ë ˆë²¨ 1ë¶€í„° ë‹¤ì‹œ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                        resetGame(false); // ë ˆë²¨ 1ë¡œ
                    } else {
                        resetGame(true); // ë ˆë²¨ ìœ ì§€
                    }
                }
            }
        }
        
        function animateCrane(targetY) {
            return new Promise(resolve => {
                const startY = clawGroup.position.y;
                const duration = 500;
                const start = performance.now();
                
                function animate() {
                    const t = Math.min((performance.now() - start) / duration, 1);
                    const ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                    
                    clawGroup.position.y = startY + (targetY - startY) * ease;
                    const ropeLen = 3.7 - clawGroup.position.y;
                    rope.scale.y = ropeLen / 1.2;
                    rope.position.y = 3.7 - ropeLen / 2;
                    
                    if (t < 1) requestAnimationFrame(animate);
                    else resolve();
                }
                animate();
            });
        }
        
        function showFeedback(text, type) {
            const el = document.createElement('div');
            el.className = `feedback ${type}`;
            el.textContent = text;
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }
        
        function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
        
        async function levelUp() {
            SFX.levelUp();
            showFeedback(`ğŸ‰ LEVEL ${state.level} CLEAR!`, 'perfect');
            setStatus(`ğŸŠ ë ˆë²¨ ${state.level} í´ë¦¬ì–´! ë‹¤ìŒ ë ˆë²¨ë¡œ...`, '');
            
            await sleep(1500);
            
            state.level++;
            gtag('event', 'level_up', { level: state.level });
            state.wins = 0;
            state.collection = [];
            state.craneX = 0;
            state.craneZ = 0;
            crane.position.set(0, 0, 0);
            
            // localStorageì— ë ˆë²¨ ì €ì¥
            try { localStorage.setItem('clawMachineLevel', state.level); } catch(e) {}
            
            document.getElementById('wins').textContent = 0;
            document.getElementById('collection').innerHTML = '';
            spawnPrizes();
            document.getElementById('grabBtn').disabled = false;
            setClawState(1);
            clawGroup.position.y = 2.5;
            
            state.isDropping = false;
            state.phase = 'idle';
            
            showFeedback(`LEVEL ${state.level}`, 'good');
            setStatus(`ğŸ“Š ë ˆë²¨ ${state.level} ì‹œì‘!`, '');
            await sleep(1000);
            hideStatus();
        }
        
        function resetGame(keepLevel = false) {
            if (!keepLevel) {
                state.level = 1;
                try { localStorage.removeItem('clawMachineLevel'); } catch(e) {}
            }
            state.wins = 0;
            state.collection = [];
            state.craneX = 0;
            state.craneZ = 0;
            crane.position.set(0, 0, 0);
            document.getElementById('wins').textContent = 0;
            document.getElementById('collection').innerHTML = '';
            spawnPrizes();
            document.getElementById('grabBtn').disabled = false;
            setClawState(1);
            clawGroup.position.y = 2.5;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ì…ë ¥
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const dpad = document.getElementById('dpad');
        const grabBtn = document.getElementById('grabBtn');
        const powerFill = document.getElementById('powerFill');
        
        dpad.querySelectorAll('.dpad-btn[data-dir]').forEach(btn => {
            const dir = btn.dataset.dir;
            const start = () => {
                if (dir === 'up') state.moveZ = -1;
                else if (dir === 'down') state.moveZ = 1;
                else if (dir === 'left') state.moveX = -1;
                else if (dir === 'right') state.moveX = 1;
                btn.classList.add('active');
            };
            const end = () => {
                if (dir === 'up' || dir === 'down') state.moveZ = 0;
                else state.moveX = 0;
                btn.classList.remove('active');
            };
            btn.addEventListener('touchstart', e => { e.preventDefault(); initAudio(); SFX.move(); start(); });
            btn.addEventListener('touchend', end);
            btn.addEventListener('touchcancel', end);
            btn.addEventListener('mousedown', () => { initAudio(); SFX.move(); start(); });
            btn.addEventListener('mouseup', end);
            btn.addEventListener('mouseleave', end);
        });
        
        grabBtn.addEventListener('touchstart', e => { e.preventDefault(); initAudio(); if (!state.isDropping) { state.isCharging = true; grabBtn.classList.add('active'); SFX.button(); } });
        grabBtn.addEventListener('touchend', () => { if (state.isCharging) { state.isCharging = false; grabBtn.classList.remove('active'); SFX.coin(); drop(); } });
        grabBtn.addEventListener('mousedown', () => { initAudio(); if (!state.isDropping) { state.isCharging = true; grabBtn.classList.add('active'); SFX.button(); } });
        grabBtn.addEventListener('mouseup', () => { if (state.isCharging) { state.isCharging = false; grabBtn.classList.remove('active'); SFX.coin(); drop(); } });
        
        document.addEventListener('keydown', e => {
            if (e.code === 'ArrowUp' || e.code === 'KeyW') state.moveZ = -1;
            else if (e.code === 'ArrowDown' || e.code === 'KeyS') state.moveZ = 1;
            else if (e.code === 'ArrowLeft' || e.code === 'KeyA') state.moveX = -1;
            else if (e.code === 'ArrowRight' || e.code === 'KeyD') state.moveX = 1;
            else if (e.code === 'Space' && !e.repeat && !state.isDropping) { e.preventDefault(); initAudio(); SFX.button(); state.isCharging = true; }
        });
        document.addEventListener('keyup', e => {
            if (e.code === 'ArrowUp' || e.code === 'KeyW') state.moveZ = 0;
            else if (e.code === 'ArrowDown' || e.code === 'KeyS') state.moveZ = 0;
            else if (e.code === 'ArrowLeft' || e.code === 'KeyA') state.moveX = 0;
            else if (e.code === 'ArrowRight' || e.code === 'KeyD') state.moveX = 0;
            else if (e.code === 'Space' && state.isCharging) { state.isCharging = false; SFX.coin(); drop(); }
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ê²Œì„ ì´ˆê¸°í™” - localStorageì—ì„œ ë ˆë²¨ ë¡œë“œ
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        try {
            const savedLevel = localStorage.getItem('clawMachineLevel');
            if (savedLevel) state.level = parseInt(savedLevel) || 1;
        } catch(e) {}
        
        spawnPrizes();
        setClawState(1);
        
        function gameLoop() {
            requestAnimationFrame(gameLoop);
            
            // í¬ë ˆì¸ ì´ë™
            if (!state.isDropping) {
                state.craneX += state.moveX * 0.05;
                state.craneZ += state.moveZ * 0.05;
                state.craneX = Math.max(-BOUNDS.x, Math.min(BOUNDS.x, state.craneX));
                state.craneZ = Math.max(-BOUNDS.z, Math.min(BOUNDS.z, state.craneZ));
                crane.position.x = state.craneX;
                crane.position.z = state.craneZ;
            }
            
            // íŒŒì›Œ
            if (state.isCharging) {
                state.power += state.powerDir * 2;
                if (state.power >= 100 || state.power <= 0) state.powerDir *= -1;
                state.power = Math.max(0, Math.min(100, state.power));
            }
            // ì›í˜• íŒŒì›Œ ê²Œì´ì§€ ì—…ë°ì´íŠ¸
            const circumference = 408; // 2 * Ï€ * 65
            const offset = circumference - (state.power / 100) * circumference;
            powerFill.style.strokeDashoffset = offset;
            // íŒŒì›Œì— ë”°ë¥¸ ìƒ‰ìƒ (ìœ„ìª½ 45-55%ê°€ PERFECT)
            let strokeColor;
            if (state.power >= 45 && state.power <= 55) strokeColor = '#00ff00';
            else if (state.power >= 30 && state.power <= 70) strokeColor = '#ffaa00';
            else strokeColor = '#ff4444';
            powerFill.style.stroke = strokeColor;
            
            // ë¬¼ë¦¬
            updatePhysics();
            
            // ì¸í˜• ëŒ€ê¸° ì• ë‹ˆë©”ì´ì…˜
            const time = performance.now() * 0.002;
            state.prizes.forEach(p => {
                if (!p.grabbed && !p.isHeld && Math.abs(p.vy) < 0.001) {
                    p.mesh.position.y = 0.1 + Math.sin(time + p.bobOffset) * 0.015;
                    p.mesh.rotation.y += 0.002;
                }
            });
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // í™”ë©´ í¬ê¸° ë³€ê²½ ì‹œ ì¹´ë©”ë¼ ê±°ë¦¬ë„ ì¡°ì ˆ
            const newDist = getCameraDistance();
            camera.position.set(0, newDist.y, newDist.z);
        });
        
        gameLoop();
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ë„ì›€ë§ ëª¨ë‹¬
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const helpBtn = document.getElementById('helpBtn');
        const helpModal = document.getElementById('helpModal');
        const helpClose = document.getElementById('helpClose');
        
        helpBtn.addEventListener('click', () => {
            helpModal.classList.add('visible');
            gtag('event', 'help_open', { help: true });
        });
        
        helpClose.addEventListener('click', () => {
            helpModal.classList.remove('visible');
            gtag('event', 'help_close', { help_close: true });
        });

        document.getElementById('lunarNewYear').addEventListener('click', () => {
            helpModal.classList.remove('visible');
            gtag('event', 'lunar_new_year', { lunar_new_year: true });
            state.wins = 0;
            state.coins += 200;
            document.getElementById('wins').textContent = 0;
            document.getElementById('coins').textContent = state.coins;
            document.getElementById('collection').innerHTML = '';
            spawnPrizes(100);
            showFeedback('ğŸ§§ ìƒˆí•´ ë³µ ë§ì´ ë°›ìœ¼ì„¸ìš”! ğŸŠ', 'perfect');
            setStatus('ğŸ§§ ì¸í˜• 100ë§ˆë¦¬ ë“±ì¥!', '');
        });
        
        helpModal.addEventListener('click', (e) => {
            if (e.target === helpModal) {
                helpModal.classList.remove('visible');
            }
        });
    </script>
</body>
</html>
